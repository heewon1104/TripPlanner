{"ast":null,"code":"import { extends as _extends } from './_virtual/_rollupPluginBabelHelpers.js';\nimport { isPlainObject } from './assertion.esm.js';\nfunction filterObject(input, keys, invert) {\n  if (invert === void 0) {\n    invert = false;\n  }\n  return Object.keys(input).filter(function (key) {\n    return invert ? !keys.includes(key) : keys.includes(key);\n  }).reduce(function (obj, key) {\n    var _Object$assign;\n    return Object.assign(obj, (_Object$assign = {}, _Object$assign[key] = input[key], _Object$assign));\n  }, {});\n}\nvar MergeOptions = function MergeOptions(options) {\n  var _options$arrayHandlin;\n  this.arrayHandling = void 0;\n  this.arrayHandling = (_options$arrayHandlin = options == null ? void 0 : options.arrayHandling) != null ? _options$arrayHandlin : 'concat';\n};\nfunction merge(options, target) {\n  for (var _len = arguments.length, sources = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    sources[_key - 2] = arguments[_key];\n  }\n  if (isPlainObject(options)) {\n    sources = [target].concat(sources);\n    target = options;\n    options = new MergeOptions();\n  }\n  if (!isPlainObject(target) || !sources.length) {\n    return target;\n  }\n  var _options = options,\n    arrayHandling = _options.arrayHandling;\n  var source = sources.shift();\n  if (!source || !isPlainObject(source)) {\n    return target;\n  }\n  Object.keys(source).forEach(function (key) {\n    var targetValue = target[key];\n    var sourceValue = source[key];\n    if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {\n      switch (arrayHandling) {\n        case 'concat':\n          target[key] = targetValue.concat(sourceValue);\n          break;\n        case 'replace':\n          target[key] = sourceValue;\n          break;\n        case 'union':\n          target[key] = Array.from(new Set([].concat(targetValue, sourceValue)));\n          break;\n      }\n    } else if (isPlainObject(targetValue) && isPlainObject(sourceValue)) {\n      target[key] = merge(options, _extends({}, targetValue), sourceValue);\n    } else {\n      target[key] = sourceValue;\n    }\n  });\n  return target;\n}\nexport { MergeOptions, filterObject, merge };","map":{"version":3,"names":["filterObject","input","keys","invert","Object","filter","key","includes","reduce","obj","_Object$assign","assign","MergeOptions","options","arrayHandling","_options$arrayHandlin","merge","target","sources","Array","_len","_key","arguments","isPlainObject","concat","length","_options","source","shift","forEach","targetValue","sourceValue","isArray","from","Set","_extends"],"sources":["C:\\Users\\이세희\\Documents\\project_oyr\\node_modules\\@sajari\\react-sdk-utils\\src\\object.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-param-reassign */\nimport { isPlainObject } from './assertion';\n\n/**\n * Filter an object to keep or remove certain keys\n * @param input Object to filter\n * @param keys Keys that can be kept or removed\n * @param invert Whether the keys are kept (false) or remove (true)\n */\nexport function filterObject(input: Record<string, any>, keys: Array<string>, invert = false): Record<string, any> {\n  return Object.keys(input)\n    .filter((key) => (invert ? !keys.includes(key) : keys.includes(key)))\n    .reduce((obj, key) => Object.assign(obj, { [key]: input[key] }), {});\n}\n\ninterface MergeObject {\n  [k: string]: any;\n}\n\ntype MergeArrayHandling = 'concat' | 'union' | 'replace';\n\nexport class MergeOptions {\n  /**\n   * How arrays should be merged\n   * 'concat' - Concatenate arrays.\n   * 'union' - Union arrays, skipping items that already exist.\n   * 'replace' - Replace all array items.\n   */\n  public arrayHandling: MergeArrayHandling;\n\n  constructor(options?: MergeOptions) {\n    this.arrayHandling = options?.arrayHandling ?? 'concat';\n  }\n}\n\n// Deep extend destination object with N more objects\nexport function merge(\n  options: MergeOptions | MergeObject,\n  target: MergeObject,\n  ...sources: MergeObject[]\n): MergeObject {\n  // If options aren't passed\n  if (isPlainObject(options)) {\n    sources = [target, ...sources];\n    target = options;\n    options = new MergeOptions();\n  }\n\n  if (!isPlainObject(target) || !sources.length) {\n    return target;\n  }\n\n  const { arrayHandling } = options as MergeOptions;\n  const source = sources.shift();\n\n  if (!source || !isPlainObject(source)) {\n    return target;\n  }\n\n  Object.keys(source).forEach((key) => {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {\n      switch (arrayHandling) {\n        case 'concat':\n          target[key] = targetValue.concat(sourceValue);\n          break;\n\n        case 'replace':\n          target[key] = sourceValue;\n          break;\n\n        case 'union':\n          target[key] = Array.from(new Set([...targetValue, ...sourceValue]));\n          break;\n\n        default:\n          break;\n      }\n    } else if (isPlainObject(targetValue) && isPlainObject(sourceValue)) {\n      target[key] = merge(options, { ...targetValue }, sourceValue);\n    } else {\n      target[key] = sourceValue;\n    }\n  });\n\n  return target;\n}\n"],"mappings":";;SAUgBA,aAAaC,KAAA,EAA4BC,IAAA,EAAqBC,MAAA;MAAAA,MAAA;IAAAA,MAAA,GAAS;;EACrF,OAAOC,MAAM,CAACF,IAAP,CAAYD,KAAZ,EACJI,MADI,CACG,UAACC,GAAD;IAAA,OAAUH,MAAM,GAAG,CAACD,IAAI,CAACK,QAAL,CAAcD,GAAd,CAAJ,GAAyBJ,IAAI,CAACK,QAAL,CAAcD,GAAd,CAAzC;GADH,EAEJE,MAFI,CAEG,UAACC,GAAD,EAAMH,GAAN;IAAA,IAAAI,cAAA;IAAA,OAAcN,MAAM,CAACO,MAAP,CAAcF,GAAd,GAAAC,cAAA,OAAAA,cAAA,CAAsBJ,GAAtB,IAA4BL,KAAK,CAACK,GAAD,CAAjC,EAAAI,cAAA,EAAd;GAFH,EAE4D,EAF5D,CAAP;AAGD;IAQYE,YAAb,GASE,SAAAA,aAAYC,OAAZ;;OAFOC,aAAA;EAGL,KAAKA,aAAL,IAAAC,qBAAA,GAAqBF,OAArB,oBAAqBA,OAAO,CAAEC,aAA9B,YAAAC,qBAAA,GAA+C,QAA/C;AACD;SAIaC,MACdH,OAAA,EACAI,MAAA;oCACGC,OAAA,OAAAC,KAAA,CAAAC,IAAA,OAAAA,IAAA,WAAAC,IAAA,MAAAA,IAAA,GAAAD,IAAA,EAAAC,IAAA;IAAAH,OAAA,CAAAG,IAAA,QAAAC,SAAA,CAAAD,IAAA;;EAGH,IAAIE,aAAa,CAACV,OAAD,CAAjB,EAA4B;IAC1BK,OAAO,IAAID,MAAJ,EAAAO,MAAA,CAAeN,OAAf,CAAP;IACAD,MAAM,GAAGJ,OAAT;IACAA,OAAO,GAAG,IAAID,YAAJ,EAAV;;EAGF,IAAI,CAACW,aAAa,CAACN,MAAD,CAAd,IAA0B,CAACC,OAAO,CAACO,MAAvC,EAA+C;IAC7C,OAAOR,MAAP;;EAGF,IAAAS,QAAA,GAA0Bb,OAA1B;IAAQC,aAAR,GAAAY,QAAA,CAAQZ,aAAR;EACA,IAAMa,MAAM,GAAGT,OAAO,CAACU,KAAR,EAAf;EAEA,IAAI,CAACD,MAAD,IAAW,CAACJ,aAAa,CAACI,MAAD,CAA7B,EAAuC;IACrC,OAAOV,MAAP;;EAGFb,MAAM,CAACF,IAAP,CAAYyB,MAAZ,EAAoBE,OAApB,CAA4B,UAACvB,GAAD;IAC1B,IAAMwB,WAAW,GAAGb,MAAM,CAACX,GAAD,CAA1B;IACA,IAAMyB,WAAW,GAAGJ,MAAM,CAACrB,GAAD,CAA1B;IAEA,IAAIa,KAAK,CAACa,OAAN,CAAcF,WAAd,KAA8BX,KAAK,CAACa,OAAN,CAAcD,WAAd,CAAlC,EAA8D;MAC5D,QAAQjB,aAAR;QACE,KAAK,QAAL;UACEG,MAAM,CAACX,GAAD,CAAN,GAAcwB,WAAW,CAACN,MAAZ,CAAmBO,WAAnB,CAAd;UACA;QAEF,KAAK,SAAL;UACEd,MAAM,CAACX,GAAD,CAAN,GAAcyB,WAAd;UACA;QAEF,KAAK,OAAL;UACEd,MAAM,CAACX,GAAD,CAAN,GAAca,KAAK,CAACc,IAAN,CAAW,IAAIC,GAAJ,IAAAV,MAAA,CAAYM,WAAZ,EAA4BC,WAA5B,EAAX,CAAd;UACA;;KAZN,MAiBO,IAAIR,aAAa,CAACO,WAAD,CAAb,IAA8BP,aAAa,CAACQ,WAAD,CAA/C,EAA8D;MACnEd,MAAM,CAACX,GAAD,CAAN,GAAcU,KAAK,CAACH,OAAD,EAAAsB,QAAA,KAAeL,WAAf,GAA8BC,WAA9B,CAAnB;KADK,MAEA;MACLd,MAAM,CAACX,GAAD,CAAN,GAAcyB,WAAd;;GAxBJ;EA4BA,OAAOd,MAAP;AACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}